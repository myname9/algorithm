# 基础概念

衡量算法适合不适合的主要标准

- 时间花了多少 -> 时间复杂度
- 内存用了多少 -> 空间复杂度


## 时间复杂度
>程序的运行时间与问题规模的对应关系

运行时间可以理解为执行的指令条数 (抛开了电脑硬件情况，天气，人品等其他因素)

问题规模可理解为需要处理的数据条数

根据需要处理的数据条数 对应 需要执行的指令条数 这种对应关系就是 时间复杂度


### 算法时间复杂度表示

渐进时间复杂度

上界 最坏情况 记作：$O (N)$

下界 最好情况 记作：$\Omega (N)$

准确的界 上界和下界增长速度一样时候 记作：$\Theta (N)$

>例如 给你N张扑克牌 按顺序查看扑克牌 找出里边的黑桃A
>上界 就是 找到最后一张才找到  复杂度为 $O (N)$
>下界 第一张就找到了 复杂度为  $\Omega (1)$

>例如 依次查看N张扑克牌 计算所有牌的和
>上界 下界 增长速度是一样的 此时 $O (N)$ $\Omega (N)$ $\Theta (N)$ 都是正确表示

>例如 一个程序实际执行时间为 $T(n) = 12n^3 + 23n^2 + 456$ 则$T(n) = O (n^3)$ 

常说的算法复杂度、时间复杂度默认就是指的 大O记法 $O (N)$

### 增长数量级

- 常数级 $O(1)$
- 对数级 $O(\log N)$
- 线性级 $O(N)$
- 线性对数级 $O(N\log N)$
- 平方级 $O(N^2)$
- 立方级 $O(N^3)$
- 指数级 $O(2^N)$

```
//常数级
sumNum = (1+n)*n/2


//线性级
sumNum = 0;
n = 100;
for(i=1;i<n+1;i++){
    sumNum+=i
}

for(i=0;i<n-3;i++){
    a+=1
    b+=1
}

//平方级级
for(i=0;i<n-3;i++){
    for(j=0;j<n;j++){
        a+=1
    }
}

```


### 增长速度

$$ O(1) &lt; O(\log N) &lt; O(N) &lt; O(N\log N) &lt; O(N^2) &lt; O(N^3) &lt; O(2^N) &lt; O(N!) &lt; O(N^N) $$


## 空间复杂度
>程序的运行从开始到结束所需的储存量与问题规模的关系
记作 $ S(N) = O( f(N) ) $ 

```
//两个变量交换彼此的值
a = 5
b = 8
//借助额外的一个变量
temp = a    //temp:5 a:5 b:8
a = b       //temp:5 a:8 b:8
b = temp    //temp:5 a:8 b:5

//两个变量交换彼此的值(不使用额外的空间)
a = 5
b = 8

a = a+b     //a=13 b=8
b = a-b     //a=13 b=5
a = a-b     //a=8  b=5

```

